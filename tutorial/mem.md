## 共享内存设计

约定每个节点至多可以存放100个服务配置，那么问题就是：
如何在共享内存上存储100个服务配置，需要满足如下条件：
- 读写效率高，读多写少（结构高效）
- 多语言支持方便（结构简单）

最终共享内存设计如下：
- 将一段共享内存划分为有100个slot的数组
- 每个slot存储一个服务配置，此服务的所有配置内容按key字典序依次连续排列
- 每个slot对应一个文件锁

如图：

![mem](tutorial/pictures/mem.png)

于是

- 读某服务sk的某配置项key：对对应slot上读锁，在slot内以key进行二分搜索
- 写某服务sk：对对应slot上写锁，直接重新对slot内容赋新值

且结构足够简单，多语言支持毫无实现难度

## agent

agent维护共享内存，并创建、持有100个文件锁

agent与broker建立长连接
一方面时刻等待broker推送最新配置，一方面周期性拉取最新服务配置
broker给出的服务配置版本如果更大，才会实际更新共享内存内容，否则忽略

## api

业务端和agent没有过多通信，仅有订阅、保活，且都通过UDP方式通信

### 订阅
api初始化时，会向agent订阅某个服务sk的配置

1. agent端检查本地，如果存在此服务，回复此服务所在slot的索引；
否则向broker订阅
2. api拿到sk的slot索引，则获取对应文件锁
3. api接下来每次读取配置项，将上读锁，并在对应slot上读取

### 保活
当某服务在某节点上不再需要（被下线），应该在共享内存中清理掉对应服务配置，故api需和agent通信保活

api创建时会启动一个后台线程、或goroutine，周期性告知agent其还在使用某配置
agent有一个goroutine负责周期性删除很久没用保活消息的服务配置

